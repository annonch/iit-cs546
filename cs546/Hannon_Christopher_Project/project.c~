#include <stdio.h>
#include <mpi.h>
#include <time.h>
#include <sys/time.h>
#include <stdlib.h>

#include "project.h"
#include "fft.c"



int MY_ID; // same as rank
int NUM_PROCS;

int MODE;
int MPI;

complex A[512][512];
complex B[512][512];
complex C[512][512];
complex D[512][512];


int main(int argc, char **argv) 
{

  int ierr;
  float totalTime;

  setup(argc,argv);
  if (MY_ID ==0){
    printf("\n\n\n-------------------------------------------------------------------");
    printf("\ncs 546 Term Project\n");
    printf("Author: Christopher Hannon\n");
    
    printf("\n\tInitializing\n");
    printf("\tStarting Timer\n");
  }
  start_exec_timer();
  if(MY_ID==0)
    printf("\n\tRunning...\n");

  switch(MODE){
  case 1:
    if(MY_ID==0)
      printf("\nrunning ALGO 1\n");
    ALGO1();
    break;
  case 2:
    if(MY_ID==0)
      printf("\nrunning ALGO 2\n");
    ALGO2();
    break;
  case 3:
    if(MY_ID==0)
      printf("\nrunning ALGO 3\n");
    ALGO3();
    break;
  case 4:
    if(MY_ID==0)
      printf("\nrunning ALGO 4 (serial)\n");
    serial();
    break;
  }
  
  totalTime = print_exec_timer();
  if(MY_ID==0){
    printf("\n\tCleaning up..\n");
    printf("\n\tResults:\n");
    print_results();
    printf("\nTotal Time Spent: %15.6f s\n", totalTime);
    cleanup();
    printf("-------------------------------------------------------------------\n\n\n");
  }
  return 0;
}

void usage(){
  printf("\nUsage: mpirun -np 8 ./project ALGO \n");
  printf("Where ALGO = 1, 2, 3, or 4\n");
  printf("algo 1 is part a\n");
  printf("algo 2 is part b\n");
  printf("algo 3 is part c\n");
  printf("algo 4 is a serial implementation (No parallelism)\n");
}

void transpose(complex a[512][512]){
  int i,j;
  complex A_i[512][512];
  for(i=0;i<512;i++)
    for(j=0;j<512;j++)
      A_i[j][i]=a[i][j];
  a=A_i;
}

void serial(){ 
  /* Serial version */
  int i,j;
  c_fft1d(*A, 512, -1);
  c_fft1d(*B, 512, -1);
  transpose(A);
  transpose(B);
  c_fft1d(*A, 512, -1);
  c_fft1d(*B, 512, -1);
  for(i=0;i<512;i++)
    for(j=0;j<512;j++){
      D[i][j].r=A[i][j].r*B[i][j].r;
      D[i][j].i=A[i][j].i*B[i][j].i;
    }
  c_fft1d(*D,512,1);
  transpose(D);
  c_fft1d(*D,512,1);
  
}

void ALGO1() {

}

void ALGO2() {

}

void ALGO3() {
  /* Task and Data Parallel Model */


}

void setup(int argc, char **argv){
  /* sets up the random numbers*/
  int ierr, my_id, num_procs;
  FILE *f_A, *f_B; // open file discriptor
  int i,j;

  my_id=0;
  
  if(argc<2){
    printf("incorrect args\n");
    usage();
    exit(1); // incorrect args
  }

  MODE = atoi(argv[1]);
  //printf("%d\n",MODE);
  if(MODE >4 || MODE <1){//!= 1 || MODE != 2 || MODE != 3 || MODE != 4) {
    printf("MODE ERROR\n");
    usage();
    exit(1);
  }
  if (MODE < 4)
    MPI=1;
  else
    MPI=0;
   
  /* MPI SETUP */
  if (MPI){
    ierr = MPI_Init(&argc, &argv);
    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &my_id);
    ierr = MPI_Comm_size(MPI_COMM_WORLD, &num_procs);
    if(MODE == 3 && num_procs != 8){
      printf("Error, number of processes for ALGO 3 need to be 8\n");
      exit(2);
    }
    if(!(num_procs == 1 || num_procs == 2 || num_procs == 4 || num_procs == 8)){
      printf("Error, num processors specified must be 1,2,4,or 8\n");
      exit(2);
    }
    if (num_procs==1)
      MODE=4;
    NUM_PROCS=num_procs;
    MY_ID=my_id;
  }

  // read inputs from https://www.programiz.com/c-programming/examples/read-file
  if ((f_A = fopen("im1", "r")) == NULL) {
      printf("Error! opening file A");
      // Program exits if file pointer returns NULL.
      exit(3);         
  }
  if ((f_B = fopen("im2", "r")) == NULL) {
      printf("Error! opening file B");
      // Program exits if file pointer returns NULL.
      exit(3);         
  }
 
  for(i=0;i<512;i++) 
    for(j=0;j<512;j++)
      fscanf(f_A,"%g",&A[i][j]);
  for(i=0;i<512;i++) 
    for(j=0;j<512;j++)
      fscanf(f_B,"%g",&B[i][j]);

  fclose(f_A);
  fclose(f_B);
}



void cleanup(){
  if (MPI){
    int ierr;
    ierr = MPI_Finalize();
  }
}

void print_results(){
  FILE *f;
  int i,j;

  if ((f = fopen("out.txt", "w")) == NULL) {
      printf("Error! opening file out");
      // Program exits if file pointer returns NULL.
      exit(3);         
  }

  
  for(i=0;i<512;i++){
    for(j=0;j<512;j++){
      fprintf(f,"%6.2g",&D[i][j]);
    }
    fprintf(f,"\n");
  }
}

/*
MPI_Send(
    void* data,
    int count,
    MPI_Datatype datatype,
    int destination,
    int tag,
    MPI_Comm communicator)

MPI_Recv(
    void* data,
    int count,
    MPI_Datatype datatype,
    int source,
    int tag,
    MPI_Comm communicator,
    MPI_Status* status)
*/
/*
int do_MPI_stuff(int val){
  int sval;
  int s1,s2,s3,s4;
  int rec;
  
  if(P==2){
    if(MY_ID  == 0) { // even
      // recieve
      MPI_Recv(&rec,1,MPI_INT,1,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      sval = rec + val;
      // return val
      MPI_Send(&sval,1,MPI_INT,1,1,MPI_COMM_WORLD);
      return val;
    }
    else{
      //sendval
      sval=val;
      MPI_Send(&sval,1,MPI_INT,0,1,MPI_COMM_WORLD);
      //recieve
      MPI_Recv(&rec,1,MPI_INT,0,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      return val+rec;
    }
  }
  
  else if(P == 4){
    if(MY_ID  == 0) { // even
      // recieve
      MPI_Recv(&rec,1,MPI_INT,1,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      sval = rec + val;
      // return val
      MPI_Send(&sval,1,MPI_INT,1,1,MPI_COMM_WORLD);

      //talk to 2
      
      return val;
    }
    else if(MY_ID == 1{
      //sendval
      sval=val;
      MPI_Send(&sval,1,MPI_INT,0,1,MPI_COMM_WORLD);
      //recieve
      MPI_Recv(&rec,1,MPI_INT,0,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      return val+rec;
    }
    if(MY_ID == 2) { // even
      // recieve
      MPI_Recv(&rec,1,MPI_INT,3,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      sval = rec + val;
      // return val

      MPI_Send(&sval,1,MPI_INT,0,1,MPI_COMM_WORLD);
      MPI_Recv(&rec,1,MPI_INT,0,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      sval = sval + rec
      
      MPI_Send(&sval,1,MPI_INT,3,1,MPI_COMM_WORLD);
      return val;
    }
    else{ //3
      //sendval
      sval=val;
      MPI_Send(&sval,1,MPI_INT,2,1,MPI_COMM_WORLD);
      //recieve
      MPI_Recv(&rec,1,MPI_INT,2,1,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
      return val+rec;
    }
  }
    
  else if(P == 8){
    
  }
  else{
    //16
  }
  
}

/* timing code is from stackoverflow */
/* https://stackoverflow.com/questions/459691/best-timing-method-in-c */

int timeval_sub(struct timeval *result, struct timeval end, struct timeval start) {
  if (start.tv_usec < end.tv_usec) {
    int nsec = (end.tv_usec - start.tv_usec) / 1000000 + 1;
    end.tv_usec -= 1000000 * nsec;
    end.tv_sec += nsec;
  }
  
  if (start.tv_usec - end.tv_usec > 1000000) {
    int nsec = (end.tv_usec - start.tv_usec)  / 1000000;
    end.tv_usec += 1000000 * nsec;					
    end.tv_sec -= nsec;							
  }									
  result->tv_sec = end.tv_sec - start.tv_sec;				
  result->tv_usec = end.tv_usec - start.tv_usec;
  return end.tv_sec < start.tv_sec;
}

float set_exec_time(int end) {
  static struct timeval time_start;
  struct timeval time_end;
  struct timeval time_diff;
  if (end) {
    gettimeofday(&time_end, NULL);
    if (timeval_sub(&time_diff, time_end, time_start) == 0) {
      if (end == 1)
        //printf("\nexec time: %1.2fs\n", time_diff.tv_sec + (time_diff.tv_usec / 1000000.0f));       
        return time_diff.tv_sec + (time_diff.tv_usec / 1000000.0f);
      else if (end == 2)
        printf("%1.2fs", time_diff.tv_sec + (time_diff.tv_usec / 1000000.0f));
    }
    return -1;
  }
  gettimeofday(&time_start, NULL);
  return 0;
}

void start_exec_timer() {
  set_exec_time(0);
}

float print_exec_timer() {
  return set_exec_time(1);
}
